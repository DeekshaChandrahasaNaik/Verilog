`timescale 1ns / 1ps

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////mux code/////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
module mux2to1_1(A,B,S,C);
    //input and output declaration
    input [31:0]A, B;
    input S;
    output [31:0]C;
    assign C = S ? A : B;
endmodule

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////Pc adder code/////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
module PC_adder_1(A, B, C);
    //input
    input [31:0]A, B;
    output [31:0]C;
    //logic
    assign C=A+B;
endmodule

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////ALU code/////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
module ALU_1(A, B, ALUCtrl,Result,Zero, Negative,Overflow,Carry);
    //declaring input ports
    input [31:0]A,B;
    input [2:0]ALUCtrl;
    //declaring output ports
    output [31:0]Result;
    output Zero, Negative,Overflow,Carry;
    
    //declaring wires
    wire [31:0]mux_1;
    wire [31:0]sum;
    wire cout;
    
    //logic design

    //B or not_b selection
    assign mux_1 = ( ALUCtrl[0]==1'b0 ) ? B : ~B;
    //output of adder
    assign {cout, sum} = A + mux_1 + ALUCtrl[0];
    //designing mux;
    assign Result = (ALUCtrl[1:0] == 2'b00) ? sum:
                    (ALUCtrl[1:0] == 2'b01) ? sum:
                    (ALUCtrl[1:0] == 2'b10) ? A & B:
                    (ALUCtrl[1:0] == 2'b11) ? A | B:
                    0;
    // zero flag                
    assign Zero = &(~Result);
    //Negative flag
    assign Negative = Result[31];
    //carry falg
    assign Carry = cout & (~ALUCtrl[1]);
    // overflow
    assign Overflow = ((~ALUCtrl[1]) & (A[31] ^ sum[31]) & (~(A[31] ^ B[31]^ ALUCtrl[0])));
endmodule

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////main logic for execute cycle/////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
module Execute_cycle(i_clk, i_rst,  RegWriteE, ResultSrcE, MemwriteE, BranchE, ALUcontrolE, ALUSrcE, RD1E, RD2E, PCE, RdE, ImmExtE, PCPlus4E
                     ,PCSrcE, PCTargetE, RegWriteM, ResultSrcM, MemwriteM, ALUResultM, WriteDataM, RdM, PCPlus4M);
    //input output declarations
    input i_clk, i_rst;
    input RegWriteE, ResultSrcE, MemwriteE, BranchE, ALUSrcE; 
    input [2:0]ALUcontrolE; 
    input [31:0]RD1E, RD2E, PCE, ImmExtE, PCPlus4E;
    input [4:0]RdE;
    output PCSrcE, RegWriteM, ResultSrcM, MemwriteM;
    output [31:0]PCTargetE, ALUResultM; 
    output [31:0]WriteDataM, PCPlus4M;
    output [4:0]RdM;
    
    // declarations of internal wires
    wire [31:0]SrcBE;
    wire [31:0]ALUResultE, WriteDataE;
    wire ZeroE, Negative, Overflow, Carry;
    
    // declarations of internal registers
    reg RegWriteE_r, ResultSrcE_r, MemwriteE_r;
    reg [31:0]ALUResultE_r, WriteDataE_r, RdE_r, PCPlus4E_r;
    
     // declarations of modules
     ///////////////////////mux///////////////////
     mux2to1_1 mux2to1(
     .A(ImmExtE),
     .B(RD2E),
     .S(ALUSrcE),
     .C(SrcBE)
     );
     
    ///////////////////////ALU instatiation///////////////////
     ALU_1 alu(
     .A(RD1E),
     .B(SrcBE), 
     .ALUCtrl(ALUcontrolE),
     .Result(ALUResultE),
     .Zero(ZeroE), 
     .Negative(Negative),
     .Overflow(Overflow),
     .Carry(Carry)
     );
     
      ///////////////////////Pc adderinstatiation///////////////////
     PC_adder_1 PC_adder_1(
     .A(PCE), 
     .B(ImmExtE), 
     .C(PCTargetE)
     );
     
     always @(posedge i_clk or negedge i_rst)
        begin
            if(i_rst == 1'b0)
                begin
                    RegWriteE_r <= 1'b0;
                    ResultSrcE_r <= 1'b0; 
                    MemwriteE_r <= 1'b0; 
                    ALUResultE_r <= 32'h00000000;
                    WriteDataE_r <= 32'h00000000;
                    RdE_r <= 5'h00;
                    PCPlus4E_r <= 32'h00000000;
                end 
            else
                begin
                    RegWriteE_r <= RegWriteE;
                    ResultSrcE_r <= ResultSrcE; 
                    MemwriteE_r <= MemwriteE; 
                    ALUResultE_r <= ALUResultE;
                    WriteDataE_r <= RD2E;
                    RdE_r <= RdE;
                    PCPlus4E_r <= PCPlus4E;
                end
          end
    //pc src assignments
    assign PCSrcE = (ZeroE & BranchE);
    //output assignments
    assign RegWriteM = RegWriteE_r;
    assign ResultSrcM = ResultSrcE_r;
    assign MemwriteM = MemwriteE_r;
    assign ALUResultM = ALUResultE_r;
    assign WriteDataM = WriteDataE_r;
    assign RdM = RdE_r;
    assign PCPlus4M = PCPlus4E_r;
    
    
    
endmodule
