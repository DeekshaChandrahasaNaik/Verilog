`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 09.09.2025 13:40:51
// Design Name: 
// Module Name: Fetch_cycle
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////
module program_counter(i_clk, i_rst, PC, PC_Next);
//input and output ports
    input i_clk, i_rst;
    input [31:0]PC_Next;
    output reg [31:0] PC;
    
    // logics
    always @(posedge i_clk)
        begin
            if(!i_rst)
                PC <= 32'h00000000;
            else
                PC <= PC_Next;
        end
endmodule

module PC_adder(A, B, C);
    //input
    input [31:0]A, B;
    output [31:0]C;
    //logic
    assign C=A+B;
endmodule

module mux2to1(A,B,S,C);
    //input and output declaration
    input [31:0]A, B;
    input S;
    output [31:0]C;
    assign C = S ? A : B;
endmodule

module instruction_memory(input [31:0]A, input rst, output [31:0]RD);
//memory creation
    reg [31:0]mem[1023:0];
    assign RD = (!rst)? 32'h00000000: mem[A[31:2]];

    initial begin
        mem[0]=32'h00500283;
        mem[1]=32'h00628433;
       // mem[2]=32'h11028433;
    end
endmodule
                
module Fetch_cycle(i_clk, i_rst, PCSrcE, PCTargetE, InstrD, PCD, PCPlus4D);
//input nd output ports declration
    input i_clk,i_rst,PCSrcE;
    input [31:0]PCTargetE;
    output [31:0]InstrD, PCD, PCPlus4D;
    // declaration of reg
    reg [31:0]InstrF_reg, PCF_reg, PCPlus4F_reg; 
    //internal wires
    wire [31:0]PCF, PCPlus4F, PCFb;
    wire [31:0]InstrF;
    
    //module intsationation
    
    //mux
    mux2to1 dut(.A(PCTargetE),.B(PCPlus4F),.S(PCSrcE),.C(PCFb));
    //PC counter
    program_counter program_counter(.i_clk(i_clk), .i_rst(i_rst), .PC(PCF), .PC_Next(PCFb));
    //Instruction memory
    instruction_memory instruction_memory(.A(PCF), .rst(i_rst), .RD(InstrF));
    //Pc adder
    PC_adder PC_adder(.A(PCF), .B(32'h00000004), .C(PCPlus4F));
    
    //fetch cycle register logic
    always@(posedge i_clk or negedge i_rst)
        begin
            if(!i_rst)
                begin
                   InstrF_reg <= 32'h00000000; 
                   PCF_reg <= 32'h00000000;  
                   PCPlus4F_reg <= 32'h00000000;  
                end
            else
                begin
                   InstrF_reg <= InstrF; 
                   PCF_reg <= PCF;  
                   PCPlus4F_reg <= PCPlus4F;  
                end
        end
        
        //output port assignment
        assign InstrD = (!i_rst) ? 32'h00000000 : InstrF_reg;
        assign PCD = (!i_rst) ? 32'h00000000 : PCF_reg;
        assign PCPlus4D = (!i_rst) ? 32'h00000000 : PCPlus4F_reg;
endmodule
